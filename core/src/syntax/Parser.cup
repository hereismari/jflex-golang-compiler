import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;

import java.util.*;
import java.io.*;

parser code {:
    public void report_error(String message, Object info){
       StringBuffer m = new StringBuffer("ERRO SINTÁTICO EM: ");

       if (info instanceof ComplexSymbol){
         ComplexSymbol s = (ComplexSymbol) info;
         if(s.value != null) m.append( s.value.toString() );
         m.append( " - Linha: " + s.getLeft().getLine() + " - Coluna: "+s.getLeft().getColumn() );
         }

       m.append(" : "+message);

       System.err.println(m);
     }

    public void report_fatal_error(String message, Object info)  {
        System.out.println("Error - " + message);
        System.exit(-1);
    }
:};

// keywords
terminal BREAK, DEFAULT, FUNC, INTERFACE, SELECT, CASE, DEFER, GO;
terminal MAP, STRUCT, CHAN, ELSE, GOTO, PACKAGE, SWITCH, CONST;
terminal FALLTHROUGH, IF, RANGE, TYPE, CONTINUE, FOR, IMPORT, RETURN, VAR;

// operation
terminal PLUS, ADDRESS, AND, MINUS, OR, LT, LTE, MUL, XOR;
terminal GT, GTE, DIV, MOD, NOT;

terminal ADD_ASSIGN, ADDRESS_ASSIGN, MINUS_ASSIGN;
terminal OR_ASSIGN, MUL_ASSIGN, XOR_ASSIGN, DIV_ASSIGN;
terminal LEFT_ASSIGN, ASSIGN, CHANNEL_ASSIGN;
terminal RIGHT_ASSIGN, AND_NOT_ASSIGN;

terminal EQ_OP, NE_OP, OR_OP, LEFT_OP, RIGHT_OP, INC_OP, SUB_OP;
terminal AND_NOT_OP, CHANNEL_OP;

// punctuation
terminal COMMA, SEMICOLON, ELLIPSIS, COLON, DOT;
terminal PAR_L, PAR_R, SQRD_L, SQRD_R, CURLY_L, CURLY_R;

// others
terminal STRING_LITERAL, IMG_LITERAL, INT_LITERAL, RUNE_LITERAL;
terminal FLOAT_LITERAL, IDENTIFIER, BLANK_IDENTIFIER;

/* --------------- Non terminals --------------- */

/* --------------- Struct ---------------------- */
non terminal StructType;
non terminal FieldDecl, FieldDeclStar1;
non terminal IdentifierList, Tag;
non terminal EmbeddedField, EmbeddedField1, EmbeddedField2;

/* --------------- Type helpers ---------------- */
non terminal Type, TypeLit;
non terminal TypeNoIdentifier;
non terminal TypeName, AuxTypeName1, TypeNameNoPar;

/* --------------- All types ------------------- */
non terminal ElementType, PointerType, BaseType, FunctionType, InterfaceType;
non terminal MapType, SliceType, KeyType, ChannelType;

/* --------------- Array ----------------------- */
non terminal ArrayLength, ArrayType;

/* --------------- Function -------------------- */
non terminal Signature, Result;
non terminal Parameters, ParameterList;
non terminal ParameterDecl, ParameterDeclStar;
non terminal FuncIdentifierList, FuncIdentifierListAux1;

non terminal IdentifierListParam;
non terminal IdentifierStar2, IdentifierStar3, IdentifierStar4;

/* --------------- Interface ------------------- */
non terminal MethodSpec, MethodSpecAux1, MethodSpecAux2;

/* --------------- Optional -------------------- */
non terminal OptMul;
non terminal OptComma;
non terminal OptIdentifierList;
non terminal OptEllipsis;

/* --------------- Auxiliary ------------------- */
non terminal AuxFieldDecl1, AuxFieldDecl2, AuxFieldDecl3, AuxFieldDecl4;
non terminal IdentifierStar1;
non terminal AuxParameters1, AuxParameters2, AuxParameterList3;
non terminal AuxParameterList1, AuxParameterList2;
non terminal AuxIntefaceType1;
non terminal AuxChannelType1;

non terminal AuxResult, AuxResult2, AuxResult3;

/* --------------- Basics ---------------------- */
non terminal BasicLit, CompositeLit;
non terminal UnaryOp, MulOp, AddOp, RelOp, BinOp;
non terminal Expression, UnaryExpr, PrimaryExpr;
non terminal X, Y;
non terminal ConstDecl;

/* --------------- Operands -------------------- */
non terminal Operand;
non terminal Literal, LiteralType, LiteralValue, LiteralValueAux1;
non terminal Element, ElementList, ElementListAux1;
non terminal KeyedElement, KeyedElementAux1, KeyedElementAux2, KeyedElementAux3;

/* --------------- IDENTIFIER + BLANK ---------- */
non terminal Identifier;

/* --------------- Tests ----------------------- */
non terminal TypeStar;
non terminal BasicLitStar;
non terminal ExpressionStar;
non terminal OperandStar;
non terminal FunctionTypeStar;

/*
Precedence    Operator
    5             *  /  %  <<  >>  &  &^
    4             +  -  |  ^
    3             ==  !=  <  <=  >  >=
    2             &&
    1             ||
*/

precedence left OR_OP;
precedence left AND;
precedence left EQ_OP, NE_OP, LT, LTE, GT, GTE;
precedence left PLUS, MINUS, OR, XOR;
precedence left MUL, DIV, MOD, LEFT_OP, RIGHT_OP, ADDRESS, AND_NOT_OP;
precedence left CHANNEL_OP;

start with Type;

Identifier ::= IDENTIFIER | BLANK_IDENTIFIER;

/* --------------- Grammar --------------------- */

/* --------------- Operation ------------------- */
BasicLitStar ::= BasicLit BasicLitStar |;
BasicLit     ::= INT_LITERAL | FLOAT_LITERAL | IMG_LITERAL | RUNE_LITERAL | STRING_LITERAL;

UnaryOp  ::= PLUS | MINUS |  NOT | XOR | MUL | ADDRESS | CHANNEL_OP;
MulOp    ::= MUL | DIV | MOD | LEFT_OP | RIGHT_OP | ADDRESS | AND_NOT_OP;
AddOp    ::= PLUS | MINUS | OR | XOR;
RelOp    ::= EQ_OP | NE_OP | LT | LTE | GT | GTE;
BinOp    ::= OR_OP | AND | RelOp | AddOp | MulOp;

/* --------------- Composite literal------------ */
CompositeLit     ::= LiteralType LiteralValue;
LiteralType      ::= StructType | ArrayType | SQRD_L ELLIPSIS SQRD_R ElementType | SliceType | MapType | TypeName;
LiteralValue     ::= CURLY_L LiteralValueAux1 CURLY_R;
LiteralValueAux1 ::= ElementList |;

ElementList      ::= KeyedElement ElementListAux1 OptComma;
ElementListAux1  ::= ElementListAux1 COMMA KeyedElement |;

KeyedElement     ::= KeyedElementAux1 KeyedElementAux2;
KeyedElementAux1 ::= Expression | LiteralValue;
KeyedElementAux2 ::= KeyedElementAux3 |;
KeyedElementAux3 ::= COLON Element;

Element          ::= Expression | LiteralValue;

/*
Existe um elemento chamado Key na spec que é IDENTIFIER | Expression | LiteralValue. Mas
eu tirei o IDENTIFIER porque Expression eventualmente leva em IDENTIFIER também. Expression -> UnaryExpr -> PrimaryExpr -> Operand -> TypeName -> IDENTIFIER
dessa forma fica mais fácil de tirar a ambiguidade de Key e Element, se não seria muito difícil já que Expression também leva em IDENTIFIER.
Deixar esse comentário aqui pra lembrar vocês de checarem se faz sentido.
*/

/* --------------- Operand --------------------- */
OperandStar    ::= OperandStar Operand |;
Operand        ::= Literal | TypeName | PAR_L Expression PAR_R;
Literal        ::= BasicLit | CompositeLit; //FIXME: FunctionLit;

/* --------------- Expression ------------------ */
//Expression = UnaryExpr | Expression binary_op Expression .
//UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .

UnaryExpr  ::= PrimaryExpr | UnaryOp UnaryExpr;
PrimaryExpr ::= Operand | IF;
Expression ::= UnaryExpr | Expression BinOp Expression;
ExpressionStar ::= ExpressionStar Expression |;

/* --------------- Const ----------------------- */
//ConstDecl      = "const" ( ConstSpec | "(" { ConstSpec ";" } ")" ) .
// ConstDecl ::= CONST AuxConstDecl1;
// AuxConstDecl1 ::= ConstSpec | PAR_L AuxConstSpec PAR_R;
// AuxConstSpec ::= AuxConstSpec ConstSpec SEMICOLON  | ;

//ConstSpec      = IdentifierList [ [ Type ] "=" ExpressionList ] .
// ConstSpec ::= IdentifierList AuxConstSpec2;

/* --------------- Struct ---------------------- */
StructType     ::= STRUCT CURLY_L FieldDeclStar1 CURLY_R;
FieldDeclStar1 ::= FieldDeclStar1 FieldDecl SEMICOLON |;
FieldDecl      ::= AuxFieldDecl1 AuxFieldDecl2;

AuxFieldDecl1 ::= IDENTIFIER AuxFieldDecl3 | BLANK_IDENTIFIER AuxFieldDecl4 | EmbeddedField1;
AuxFieldDecl3 ::= IdentifierStar1 Type | DOT IDENTIFIER |;
AuxFieldDecl4 ::= IdentifierStar1 Type;
AuxFieldDecl2 ::= | Tag;

Tag ::= STRING_LITERAL;

EmbeddedField1 ::= MUL TypeName;
OptMul ::= MUL |;

IdentifierList ::= Identifier IdentifierStar1;
IdentifierStar1 ::= COMMA Identifier IdentifierStar1 |;

TypeStar ::= Type TypeStar |;
Type ::= TypeName | TypeLit | PAR_L Type PAR_R;

TypeName     ::= IDENTIFIER:i {: System.out.println("tn: " + i); :} AuxTypeName1;
AuxTypeName1 ::= DOT IDENTIFIER:i {: System.out.println(i); :} |;

TypeLit     ::= ArrayType | PointerType | SliceType | MapType | ChannelType | StructType | InterfaceType | FunctionType;

/* --------------- Array ----------------------- */
ArrayLength ::= INT_LITERAL; // FIXME: Array Length should be an Expression
ArrayType   ::= SQRD_L ArrayLength SQRD_R ElementType;
ElementType ::= Type;

PointerType ::= MUL BaseType;
BaseType    ::= Type;

/* --------------- Function -------------------- */
FunctionTypeStar ::= FunctionTypeStar FunctionType |;
FunctionType     ::= FUNC Signature;
Signature        ::= Parameters AuxResult;
AuxResult        ::= Result |;

Result         ::= PAR_L AuxResult2 PAR_R | TypeLit | TypeName;
AuxResult2     ::= Identifier AuxResult3 | TypeLit | PAR_L Type PAR_R;
AuxResult3     ::= IdentifierStar3 | DOT Identifier;

Parameters          ::= PAR_L AuxParameters1 PAR_R;
AuxParameters1      ::= ParameterList | ;
OptComma            ::= COMMA |;

ParameterList       ::= ParameterDecl;

TypeNoIdentifier    ::= TypeLit | PAR_L Type PAR_R;
ParameterDecl       ::= IdentifierListParam |
					    ELLIPSIS Type ParameterDeclStar |
					    TypeNoIdentifier ParameterDeclStar;

ParameterDeclStar   ::= COMMA ParameterDecl | COMMA | ;
IdentifierListParam ::= Identifier IdentifierStar3;  // include all posibilities
IdentifierStar3     ::= IdentifierStar2 |;
IdentifierStar2     ::= COMMA IdentifierStar4 |
                        ELLIPSIS Type ParameterDeclStar |
                        Type ParameterDeclStar;
IdentifierStar4     ::= IdentifierListParam | TypeNoIdentifier; // Type

FuncIdentifierList     ::= Identifier FuncIdentifierListAux1;
FuncIdentifierListAux1 ::= FuncIdentifierListAux1 COMMA Identifier |;

/* --------------- Interface ------------------- */
InterfaceType      ::= INTERFACE CURLY_L AuxIntefaceType1 CURLY_R;
AuxIntefaceType1   ::= AuxIntefaceType1 MethodSpec SEMICOLON |;
MethodSpec         ::= IDENTIFIER MethodSpecAux1;
MethodSpecAux1     ::= Signature | MethodSpecAux2;
MethodSpecAux2     ::= DOT IDENTIFIER |;

/* --------------- Slice ----------------------- */
SliceType ::= SQRD_L SQRD_R ElementType;

/* --------------- Map ------------------------- */
MapType     ::= MAP SQRD_L KeyType SQRD_R ElementType;
KeyType     ::= Type;

/* --------------- Channel --------------------- */
ChannelType     ::= AuxChannelType1 ElementType;
AuxChannelType1 ::= CHAN | CHAN CHANNEL_OP | CHANNEL_OP CHAN;
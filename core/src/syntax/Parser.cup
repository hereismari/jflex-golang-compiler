import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;

import java.util.*;
import java.io.*;

parser code {:
    public void report_error(String message, Object info){
       StringBuffer m = new StringBuffer("ERRO SINT√ÅTICO EM: ");

       if (info instanceof ComplexSymbol){
         ComplexSymbol s = (ComplexSymbol) info;
         if(s.value != null) m.append( s.value.toString() );
         m.append( " - Linha: " + s.getLeft().getLine() + " - Coluna: "+s.getLeft().getColumn() );
         }

       m.append(" : "+message);

       System.err.println(m);
     }

    public void report_fatal_error(String message, Object info)  {
        System.out.println("Error - " + message);
        System.exit(-1);
    }
:};

// keywords
terminal BREAK, DEFAULT, FUNC, INTERFACE, SELECT, CASE, DEFER, GO;
terminal MAP, STRUCT, CHAN, ELSE, GOTO, PACKAGE, SWITCH, CONST;
terminal FALLTHROUGH, IF, RANGE, TYPE, CONTINUE, FOR, IMPORT, RETURN, VAR;

// operation
terminal PLUS, ADDRESS, AND, MINUS, OR, LT, LTE, MUL, XOR;
terminal GT, GTE, DIV, MOD, NOT;

terminal ADD_ASSIGN, ADDRESS_ASSIGN, MINUS_ASSIGN;
terminal OR_ASSIGN, MUL_ASSIGN, XOR_ASSIGN, DIV_ASSIGN;
terminal LEFT_ASSIGN, ASSIGN, CHANNEL_ASSIGN;
terminal RIGHT_ASSIGN, AND_NOT_ASSIGN;

terminal EQ_OP, NE_OP, OR_OP, LEFT_OP, RIGHT_OP, INC_OP, SUB_OP;
terminal AND_NOT_OP, CHANNEL_OP;

// punctuation
terminal COMMA, SEMICOLON, ELLIPSIS, COLON, DOT;
terminal PAR_L, PAR_R, SQRD_L, SQRD_R, CURLY_L, CURLY_R;

// others
terminal STRING_LITERAL, IMG_LITERAL, INT_LITERAL, RUNE_LITERAL;
terminal FLOAT_LITERAL, IDENTIFIER, BLANK_IDENTIFIER;

/* --------------- Non terminals --------------- */

/* --------------- Struct ---------------------- */
non terminal StructType;
non terminal FieldDecl, FieldDeclStar1;
non terminal IdentifierList, Tag;
non terminal EmbeddedField, EmbeddedField1, EmbeddedField2;

/* --------------- Type helpers ---------------- */
non terminal Type, TypeLit;
non terminal TypeName, AuxTypeName1;

/* --------------- All types ------------------- */
non terminal ElementType, PointerType, BaseType, FunctionType, InterfaceType;
non terminal MapType, SliceType, KeyType, ChannelType;

/* --------------- Array ----------------------- */
non terminal ArrayLength, ArrayType;

/* --------------- Function -------------------- */
non terminal Signature, Result, AuxResult;
non terminal Parameters, ParameterList;
non terminal ParameterDecl;
non terminal FuncIdentifierList, FuncIdentifierListAux1;

/* --------------- Interface ------------------- */
non terminal MethodSpec, MethodSpecAux1, MethodSpecAux2;

/* --------------- Optional -------------------- */
non terminal OptMul;
non terminal OptComma;
non terminal OptIdentifierList;
non terminal OptEllipsis;

/* --------------- Auxiliary ------------------- */
non terminal AuxFieldDecl1, AuxFieldDecl2, AuxFieldDecl3, AuxFieldDecl4;
non terminal IdentifierStar1;
non terminal AuxParameters1, AuxParameterList1;
non terminal AuxIntefaceType1;
non terminal AuxChannelType1;

/* --------------- Basics ---------------------- */
non terminal BasicLit;
non terminal UnaryOp, MulOp, AddOp, RelOp, BinOp;
non terminal Expression, UnaryExpr;
non terminal X, Y;
non terminal ConstDecl, ConstSpec, AuxConstSpec, AuxConstSpec2, AuxConstDecl1;
non terminal AuxCommaExp, IdentifierListStarAux, IdentifierListStar2, ExpressionListStar;
non terminal OptType;
non terminal Statement, StatementList, StatementListAux;
non terminal SimpleStmt, ShortVarDecl, AuxExpression, Assignment, AssignOp, AuxOp;
non terminal ExpressionList;
non terminal Declaration;
non terminal TypeDecl, TypeDeclAux, TypeSpecAux, TypeSpec;
non terminal OptAssign, OptAssignExpList;
non terminal VarDecl, VarDeclAux, VarSpecAux, VarSpecAux2, VarSpec;
non terminal LabeledStmt, GoStmt, ReturnStmt, BreakStmt, ContinueStmt, GotoStmt;
non terminal FallthroughStmt, Block, DeferStmt;

/* --------------- Operands -------------------- */
non terminal Operand;
non terminal Literal;

/* --------------- IDENTIFIER + BLANK ---------- */
non terminal Identifier;

/* --------------- Tests ----------------------- */
non terminal TypeStar;
non terminal BasicLitStar;
non terminal ExpressionStar;
non terminal OperandStar;

/*
Precedence    Operator
    5             *  /  %  <<  >>  &  &^
    4             +  -  |  ^
    3             ==  !=  <  <=  >  >=
    2             &&
    1             ||
*/

precedence left OR_OP;
precedence left AND;
precedence left EQ_OP, NE_OP, LT, LTE, GT, GTE;
precedence left PLUS, MINUS, OR, XOR;
precedence left MUL, DIV, MOD, LEFT_OP, RIGHT_OP, ADDRESS, AND_NOT_OP;

precedence left CHANNEL_OP;  // HOTFIX: Franklin has given permition.

start with Statement;

Identifier ::= IDENTIFIER | BLANK_IDENTIFIER;

/* --------------- Grammar --------------------- */

/* --------------- Operation ------------------- */
BasicLitStar ::= BasicLit BasicLitStar |;
BasicLit     ::= INT_LITERAL | FLOAT_LITERAL | IMG_LITERAL | RUNE_LITERAL | STRING_LITERAL;

UnaryOp  ::= PLUS | MINUS |  NOT | XOR | MUL | ADDRESS | CHANNEL_OP;
MulOp    ::= MUL | DIV | MOD | LEFT_OP | RIGHT_OP | ADDRESS | AND_NOT_OP;
AddOp    ::= PLUS | MINUS | OR | XOR;
RelOp    ::= EQ_OP | NE_OP | LT | LTE | GT | GTE;
BinOp    ::= OR_OP | AND | RelOp | AddOp | MulOp;

/* --------------- Operand --------------------- */
OperandStar    ::= OperandStar Operand |;
Operand        ::= Literal | TypeName | PAR_L Expression PAR_R;
Literal        ::= BasicLit; //FIXME: CompositeLit | FunctionLit;

/* --------------- Expression ------------------ */
//Expression = UnaryExpr | Expression binary_op Expression .
//UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .

UnaryExpr  ::= IF | UnaryOp; // FixMe: PrimaryExpr | unary_op UnaryExpr .
Expression ::= UnaryExpr | Expression BinOp Expression;
ExpressionStar ::= ExpressionStar Expression |;


/* --------------- Const ----------------------- */

AuxCommaExp ::= AuxCommaExp COMMA Expression | ;
ExpressionList ::= Expression AuxCommaExp;
OptType ::= Type | ;
AuxConstSpec2 ::= OptType ASSIGN ExpressionList | ;
IdentifierListStarAux ::= IdentifierListStarAux COMMA IDENTIFIER | ;
IdentifierListStar2 ::= IDENTIFIER IdentifierListStarAux;
ConstSpec ::= IdentifierListStar2 AuxConstSpec2;
AuxConstSpec ::= AuxConstSpec ConstSpec SEMICOLON  | ;
AuxConstDecl1 ::= ConstSpec | PAR_L AuxConstSpec PAR_R;
ConstDecl ::= CONST AuxConstDecl1;

/* --------------- Statement ------------------ */

ShortVarDecl ::=  IdentifierListStar2 CHANNEL_ASSIGN ExpressionList;
AuxOp ::= AddOp | MulOp | ;
AssignOp ::= AuxOp ASSIGN;
Assignment ::= ExpressionList AssignOp ExpressionList;
AuxExpression ::= CHANNEL_OP Expression | INC_OP | SUB_OP | ;
SimpleStmt ::= Expression AuxExpression | Assignment | ShortVarDecl | ; 

StatementList ::= Statement SEMICOLON;
StatementListAux ::= StatementListAux StatementList | ;//FIXME: kleene doesn't work
Block ::= CURLY_L StatementList CURLY_R;

DeferStmt ::= DEFER Expression;

FallthroughStmt ::= FALLTHROUGH;

GotoStmt ::= GOTO IDENTIFIER;

ContinueStmt ::= CONTINUE Identifier;

BreakStmt ::= BREAK Identifier;

ExpressionListStar ::= ExpressionList | ;
ReturnStmt ::= RETURN ExpressionListStar;

GoStmt ::= GO Expression;

LabeledStmt ::= IDENTIFIER COLON Statement;

OptAssign ::= ASSIGN | ;
OptAssignExpList ::= ASSIGN ExpressionList | ;

VarSpecAux2 ::= Type OptAssignExpList | ASSIGN ExpressionList;
VarSpec ::= IdentifierListStar2 VarSpecAux2;
VarSpecAux ::= VarSpecAux VarSpec SEMICOLON | ;
VarDeclAux ::= VarSpec | PAR_L VarSpecAux PAR_R;
VarDecl ::= VAR VarDeclAux;

TypeSpec ::= IDENTIFIER OptAssign Type;
TypeSpecAux::= TypeSpecAux TypeSpec SEMICOLON | ;
TypeDeclAux ::= TypeSpec | PAR_L TypeSpecAux PAR_R;
TypeDecl ::= TYPE TypeDeclAux;

Declaration ::= ConstDecl | TypeDecl | VarDecl;

// FALTANDO: IfStmt | SwitchStmt | SelectStmt | ForStmt 
//FIXME: faltando IfStmt, muitos conflitos. Ja dizia marina joyce, #HELP
Statement ::= Declaration | LabeledStmt | SimpleStmt | GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt | FallthroughStmt | Block | DeferStmt;

/* --------------- Struct ---------------------- */
StructType     ::= STRUCT CURLY_L FieldDeclStar1 CURLY_R;
FieldDeclStar1 ::= FieldDeclStar1 FieldDecl SEMICOLON |;
FieldDecl      ::= AuxFieldDecl1 AuxFieldDecl2;

AuxFieldDecl1 ::= IDENTIFIER AuxFieldDecl3 | BLANK_IDENTIFIER AuxFieldDecl4 | EmbeddedField1;
AuxFieldDecl3 ::= IdentifierStar1 Type | DOT IDENTIFIER |;
AuxFieldDecl4 ::= IdentifierStar1 Type;
AuxFieldDecl2 ::= | Tag;

Tag ::= STRING_LITERAL;

EmbeddedField1 ::= MUL TypeName;
OptMul ::= MUL |;

IdentifierList ::= Identifier IdentifierStar1 |;
IdentifierStar1 ::= COMMA Identifier IdentifierStar1 |;

TypeStar ::= Type TypeStar |;
Type ::= TypeName | TypeLit | PAR_L Type PAR_R;

TypeName     ::= IDENTIFIER AuxTypeName1;
AuxTypeName1 ::= DOT IDENTIFIER |;

TypeLit     ::= ArrayType | PointerType | SliceType | MapType | ChannelType | StructType; // FIXME: Missing InterfaceType and FunctionType;

/* --------------- Array ----------------------- */
ArrayLength ::= INT_LITERAL; // FIXME: Array Length should be an Expression
ArrayType   ::= SQRD_L ArrayLength SQRD_R ElementType;
ElementType ::= Type;

PointerType ::= MUL BaseType;
BaseType    ::= Type;

/* --------------- Function -------------------- */
FunctionType   ::= FUNC Signature;
Signature      ::= Parameters AuxResult;
AuxResult      ::= Result |;
Result         ::= Parameters | Type;

Parameters     ::= PAR_L AuxParameters1 PAR_R;
AuxParameters1 ::= ParameterList OptComma |;
OptComma       ::= COMMA |;

ParameterList     ::= ParameterDecl AuxParameterList1;
AuxParameterList1 ::= AuxParameterList1 COMMA ParameterDecl |;
ParameterDecl     ::= OptIdentifierList OptEllipsis Type;
OptIdentifierList ::= FuncIdentifierList |;
OptEllipsis       ::= ELLIPSIS |;

FuncIdentifierList     ::= Identifier FuncIdentifierListAux1;
FuncIdentifierListAux1 ::= FuncIdentifierListAux1 COMMA Identifier |;

/* --------------- Interface ------------------- */
InterfaceType      ::= INTERFACE CURLY_L AuxIntefaceType1 CURLY_R;
AuxIntefaceType1   ::= AuxIntefaceType1 MethodSpec SEMICOLON |;
MethodSpec         ::= IDENTIFIER MethodSpecAux1;
MethodSpecAux1     ::= Signature | MethodSpecAux2;
MethodSpecAux2     ::= DOT IDENTIFIER |;

/* --------------- Slice ----------------------- */
SliceType ::= SQRD_L SQRD_R ElementType;

/* --------------- Map ------------------------- */
MapType     ::= MAP SQRD_L KeyType SQRD_R ElementType;
KeyType     ::= Type;

/* --------------- Channel --------------------- */
ChannelType     ::= AuxChannelType1 ElementType;
AuxChannelType1 ::= CHAN | CHAN CHANNEL_OP | CHANNEL_OP CHAN;
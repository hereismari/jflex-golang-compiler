import java_cup.runtime.*;
import java.util.*;
import java.io.*;

parser code {:
    public void report_error(String message, Object info)  {
        System.out.println("Warning - " + message);
    }

    public void report_fatal_error(String message, Object info)  {
        System.out.println("Error - " + message);
        System.exit(-1);
    }
:};

// keywords
terminal BREAK, DEFAULT, FUNC, INTERFACE, SELECT, CASE, DEFER, GO;
terminal MAP, STRUCT, CHAN, ELSE, GOTO, PACKAGE, SWITCH, CONST;
terminal FALLTHROUGH, IF, RANGE, TYPE, CONTINUE, FOR, IMPORT, RETURN, VAR;

// operation
terminal PLUS, ADDRESS, AND, MINUS, OR, LT, LTE, MUL, XOR;
terminal GT, GTE, DIV, MOD, NOT;

terminal ADD_ASSIGN, ADDRESS_ASSIGN, MINUS_ASSIGN;
terminal OR_ASSIGN, MUL_ASSIGN, XOR_ASSIGN, DIV_ASSIGN;
terminal LEFT_ASSIGN, ASSIGN, CHANNEL_ASSIGN;
terminal RIGHT_ASSIGN, AND_NOT_ASSIGN;

terminal EQ_OP, NE_OP, OR_OP, LEFT_OP, RIGHT_OP, INC_OP, SUB_OP;
terminal AND_NOT_OP, CHANNEL_OP;

// punctuation
terminal COMMA, SEMICOLON, ELLIPSIS, COLON, DOT;
terminal PAR_L, PAR_R, SQRD_L, SQRD_R, CURLY_L, CURLY_R;

// others
terminal STRING_LITERAL, IMG_LITERAL, INT_LITERAL, RUNE_LITERAL;
terminal FLOAT_LITERAL, IDENTIFIER;

/* Non terminals */

// Struct related
non terminal StructType;
non terminal FieldDeclStar1, FieldDecl;
non terminal IdentifierList, EmbeddedField, Tag;
non terminal Type, TypeName, TypeLit;
non terminal TypeNameNoIdentifier;
non terminal QualifiedIdent;
non terminal PackageName;
non terminal ArrayLength, ArrayType;

non terminal ElementType, PointerType, BaseType, FunctionType, InterfaceType;
non terminal MapType, SliceType, KeyType, ChannelType;

non terminal Signature, AuxResult, Result;
non terminal Parameters, ParameterList;
non terminal ParameterDecl;

non terminal MethodSpec, MethodName, InterfaceTypeName;

// Optional
non terminal OptMul;
non terminal OptComma;
non terminal OptIdentifierList;
non terminal OptEllipsis;

// Aux. terminals
non terminal AuxFieldDecl1, AuxFieldDecl2, AuxFieldDecl3;
non terminal IdentifierStar1;
non terminal AuxParameters1, AuxParameterList1;
non terminal AuxIntefaceType1;
non terminal AuxChannelType1;

non terminal BasicLit;
non terminal UnaryOp, MulOp, AddOp, RelOp, BinOp;
non terminal Expression, UnaryExpr;
non terminal X, Y;

// ConstDeclaration
non terminal ConstDecl;

/*
Precedence    Operator
    5             *  /  %  <<  >>  &  &^
    4             +  -  |  ^
    3             ==  !=  <  <=  >  >=
    2             &&
    1             ||
*/

precedence left OR_OP;
precedence left AND;
precedence left EQ_OP, NE_OP, LT, LTE, GT, GTE;
precedence left PLUS, MINUS, OR, XOR;
precedence left MUL, DIV, MOD, LEFT_OP, RIGHT_OP, ADDRESS, AND_NOT_OP;
precedence left CHANNEL_OP;

start with QualifiedIdent;

/* grammar */
/* ------------ Operands ------------ */
BasicLit ::= INT_LITERAL | FLOAT_LITERAL | IMG_LITERAL | RUNE_LITERAL | STRING_LITERAL;

//unary_op   = "+" | "-" | "!" | "^" | "*" | "&" | "<-" .
UnaryOp  ::= PLUS | MINUS |  NOT | XOR | MUL | ADDRESS | CHANNEL_OP;

//mul_op     = "*" | "/" | "%" | "<<" | ">>" | "&" | "&^" .
MulOp    ::= MUL | DIV | MOD | LEFT_OP | RIGHT_OP | ADDRESS | AND_NOT_OP;

//add_op     = "+" | "-" | "|" | "^" .
AddOp    ::= PLUS | MINUS | OR | XOR;

//rel_op     = "==" | "!=" | "<" | "<=" | ">" | ">=" .
RelOp    ::= EQ_OP | NE_OP | LT | LTE | GT | GTE;

//binary_op  = "||" | "&&" | rel_op | add_op | mul_op .
BinOp    ::= OR_OP | AND | RelOp | AddOp | MulOp;

//Expression = UnaryExpr | Expression binary_op Expression .
//UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .

UnaryExpr  ::= IF | UnaryOp; // FixMe: PrimaryExpr | unary_op UnaryExpr .
Expression ::= UnaryExpr | Expression BinOp Expression;

/* ------------ Const Declaration ------------ */
//ConstDecl      = "const" ( ConstSpec | "(" { ConstSpec ";" } ")" ) .
// ConstDecl ::= CONST AuxConstDecl1;
// AuxConstDecl1 ::= ConstSpec | PAR_L AuxConstSpec PAR_R;
// AuxConstSpec ::= AuxConstSpec ConstSpec SEMICOLON  | ;

//ConstSpec      = IdentifierList [ [ Type ] "=" ExpressionList ] .
// ConstSpec ::= IdentifierList AuxConstSpec2;


/* ------------ Struct -------------- */
StructType ::= STRUCT CURLY_L FieldDeclStar1 CURLY_R;
FieldDeclStar1 ::= FieldDeclStar1 FieldDecl SEMICOLON |; // FieldDeclStar1 FieldDecl SEMICOLON |;
FieldDecl ::= AuxFieldDecl1 | AuxFieldDecl2;

AuxFieldDecl1 ::= IDENTIFIER AuxFieldDecl3; // IdentifierList Type | EmbeddedField
AuxFieldDecl3 ::= IdentifierStar1 Type | EmbeddedField;
AuxFieldDecl2 ::= | Tag;
	
Tag ::= STRING_LITERAL;

EmbeddedField ::= TypeNameNoIdentifier | MUL;
OptMul ::= MUL |;

IdentifierList ::= IDENTIFIER IdentifierStar1;
IdentifierStar1 ::= IdentifierStar1 COMMA IDENTIFIER |;

Type ::= TypeName | TypeLit | PAR_L Type PAR_R;
TypeName ::= IDENTIFIER | QualifiedIdent;
TypeNameNoIdentifier ::= QualifiedIdent;
TypeLit ::= ArrayType | StructType | PointerType | FunctionType | InterfaceType | SliceType | MapType | ChannelType;

QualifiedIdent ::= PackageName DOT IDENTIFIER;
PackageName ::= IDENTIFIER; // FIXME: PackageName cant be blank identifier _

ArrayLength ::= INT_LITERAL; // FIXME: Array length actually is an expression
ArrayType ::= SQRD_L ArrayLength SQRD_R ElementType;
ElementType ::= Type;

PointerType ::= MUL BaseType;
BaseType ::= Type;

/* Functions */
FunctionType   ::= FUNC Signature;
Signature      ::= Parameters AuxResult;
AuxResult      ::= Result |;
Result         ::= Parameters | Type;

Parameters     ::= PAR_L AuxParameters1 PAR_R;
AuxParameters1 ::= ParameterList OptComma |;
OptComma       ::= COMMA |;

ParameterList  ::= ParameterDecl AuxParameterList1;
AuxParameterList1 ::= AuxParameterList1 COMMA ParameterDecl |;
ParameterDecl   ::= OptIdentifierList OptEllipsis Type;
OptIdentifierList ::= IdentifierList |;
OptEllipsis     ::= ELLIPSIS |; 

InterfaceType      ::= INTERFACE PAR_L AuxIntefaceType1 PAR_R;
AuxIntefaceType1   ::= AuxIntefaceType1 MethodSpec SEMICOLON |;
MethodSpec         ::= MethodName Signature | InterfaceTypeName;
MethodName         ::= IDENTIFIER;
InterfaceTypeName  ::= TypeName;

SliceType ::= SQRD_L SQRD_R ElementType;

MapType     ::= MAP SQRD_L KeyType SQRD_R ElementType;
KeyType     ::= Type;

ChannelType ::= AuxChannelType1 ElementType;
AuxChannelType1 ::= CHAN | CHAN CHANNEL_OP | CHANNEL_OP CHAN;


/*
terminal PROGRAM, BEGIN, END, VARIABLE, COLON, INTEGER_TYPE, STRING_TYPE, CALL_FUNCTION;
terminal RIGHT_PARAMETER, LEFT_PARAMETER, INTEGER, STRING, SEMICOLON, FUNCTION;
terminal FUNCTION_PARAMS, LEFT_BRACKETS, RIGHT_BRACKETS, TT, FF, IF, ASSIGNMENT;
terminal SYMBOL_ASSIGNMENT;

terminal IDENTIFIER, CONSTANT, STRING_LITERAL, SIZEOF, PTR_OP, INC_OP, DEC_OP, LEFT_OP, RIGHT_OP, LE_OP, GE_OP, EQ_OP, NE_OP,
    AND_OP, OR_OP, MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, ADD_ASSIGN, SUB_ASSIGN, LEFT_ASSIGN, RIGHT_ASSIGN, AND_ASSIGN,
    XOR_ASSIGN, OR_ASSIGN, TYPE_NAME, TYPEDEF, EXTERN, STATIC, AUTO, REGISTER,
    CHAR, SHORT, INT, LONG, SIGNED, UNSIGNED, FLOAT, DOUBLE, CONST, VOLATILE, VOID, STRUCT, UNION, ENUM, ELLIPSIS,
    CASE, DEFAULT, IF, ELSE, SWITCH, WHILE, DO, FOR, GOTO, CONTINUE, BREAK, RETURN,
    SEMI, CURLYL, CURLYR, COMMA, COLON, ASSIGN, PARAL, PARAR, SQUAREDL, SQUAREDR, POINT, ADRESS, NOT, TILDE, MINUS, PLUS, MUL, DIVIDE, MODULUS, LESS, GREATER, XOR, OR, COND;

non terminal program, statements, statement, statement_function;
non terminal decl_variable, decl_call_function, decl_call_params, decl_params, decl_function, decl_if;
non terminal decl_boolean,decl_assignments, decl_assignment;
non terminal params_type, data_types;

start with program;

program ::= PROGRAM BEGIN statements END;

statements ::= statements statement | statement ;

statement ::= decl_variable | decl_call_function | decl_function;

decl_function ::= FUNCTION LEFT_PARAMETER decl_params RIGHT_PARAMETER LEFT_BRACKETS statement_function RIGHT_BRACKETS;

decl_params ::= decl_params SEMICOLON FUNCTION_PARAMS | FUNCTION_PARAMS | ;

statement_function ::= statement_function decl_if | decl_if;
decl_if ::= IF decl_boolean LEFT_BRACKETS decl_assignments RIGHT_BRACKETS;

decl_assignments ::= decl_assignments decl_assignment | decl_assignment ; 

decl_assignment ::= ASSIGNMENT SYMBOL_ASSIGNMENT FUNCTION_PARAMS COLON;

decl_boolean ::= TT | FF;

decl_call_function ::= CALL_FUNCTION LEFT_PARAMETER decl_call_params RIGHT_PARAMETER COLON;
decl_call_params ::= decl_call_params SEMICOLON params_type | params_type | ;
params_type ::= INTEGER | STRING;

decl_variable ::= VARIABLE data_types COLON;
data_types ::= INTEGER_TYPE | STRING_TYPE; */